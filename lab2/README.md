# Интернет вещей. Лабораторная №2

## Сканер I2C

I²C - протокол для связи между микросхемами внутри одного устройства. Он использует всего две линии связи: SDA(данные) и SDL(тактовый сигнал). Устройства к этим линиям подключаются параллельно. Каждое устройство 
имеет 7-ми битный адрес.

• Для выполнения работы нужно подключить ADXL345 и BME280 и спомощью выводимой таблицы определить 
адреса этих устройств.


## Акселерометр

Акселерометр - измеряет ускорение по трем осям: X, Y и Z. Внутри чипа находятся микроскопические емкостные сенсоры, которые при ускорении смещаются, изменяя емкость. Электроника преобразует эти изменения в цифровые значения.

```
esp_err_t adxl345_write_reg(uint8_t reg_addr, uint8_t data)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    
    i2c_master_start(cmd);  // START условие
    i2c_master_write_byte(cmd, (ADXL345_ADDR << 1) | I2C_MASTER_WRITE, true); // Адрес + запись
    i2c_master_write_byte(cmd, reg_addr, true);  // Адрес регистра
    i2c_master_write_byte(cmd, data, true);      // Данные для записи
    i2c_master_stop(cmd);   // STOP условие
    
    err = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    return err;
}
```
• Процесс записи: START → Адрес+W → Регистр → Данные → STOP

```
esp_err_t adxl345_read_regs(uint8_t reg_addr, uint8_t *data, size_t len)
{
    // Сначала записываем адрес регистра для чтения
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ADXL345_ADDR << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg_addr, true);

    // Затем читаем данные
    i2c_master_start(cmd);  // Повторный START
    i2c_master_write_byte(cmd, (ADXL345_ADDR << 1) | I2C_MASTER_READ, true);
    if (len > 1) {
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);  // ACK для всех кроме последнего
    }
    i2c_master_read_byte(cmd, data + len - 1, I2C_MASTER_NACK); // NACK для последнего
    i2c_master_stop(cmd);
}
```
• Процесс чтения: START → Адрес+W → Регистр → Повторный START → Адрес+R → Чтение данных → STOP

## Дальномер 

Дальнометр использует звуковые волны для измерения расстояния до предметов. Излучатель послыет ультразвуковой импульс. Приемник 
ждет отраженный сигнал от препрятствия. Измеряет время между отправкой и приемом эха. Далее происходит рассчет расстояния по скорости звука.

Ключевые компоненты:
1) TRIG - вход для запуска измерения
2) ECHO - выход с результатом измерения
3) Ультразвуковой излучатель - отправляет сигнал
4) Ультразвуковой приемник - принимает отраженный сигнал

Генерация импульса для TRIG:
```
      ┌───────────────┐
      │               │
──────┘               └──────
      │←─── 10 µs ───→│
```
Для начала гарантируем низкий уровень, ждем 2мкс, поднимаем TRIG до высокого уровня и держим так 10мкс, затем вновь опускаем.

Временная диаграмма ECHO:
```
            ┌────────────────────────────┐
            │                            │
────────────┘                            └─────────────
            │←─── duration_us (в µs) ───→│
```
Для начала запомним время старта и ждем пока ECHO станет в высоком уровне, замерим время начала импульса. Ждем пока ECHO станет в низкий уровень и замеряем время окончания импульса.


## BME280

Нужно просто запустить код, так как теоретическая часть будет лежать в РГР.

• Дополнительные комоненты:
```
idf.py add-dependency "espressif/bme280=*"
idf.py fullclean
idf.py reconfigure
idf.py build
```

## RTOS Fundamentals

### Введение 

RTOS - это тип операционной системы созданный для быстрой реагирования на события.

### Многозадачность

В FreeRTOS нет подраздеения на потоки и процессы, есть только задачи.

Преимущства:
1) Позволяет разбить более сложное приложение на маленькие задачи.
2) Облегчает тестирование, совместную работу и повторное использование кода.
3) RTOS берет на себя сложное управление временем и последовательность выполнения.

RTOS позволяет быстро переключаться между задачами, что создает эффект одновременного выполнения.

### Планирование задач

Планировщик - часть ядра, которая выбирает, какая задача сейчас будет выполняться.

Задача может быть: приостановлена, возобновлена, сдаваться, задерживаться.

### Потоки или так называемые задачи

Задачи по сути это отдельные потоки, которые выполняются параллельно. У каждой задачи есть стек, приоритет и состояние. Планировщик FreeRTOS управляет переключением задач, реализуя кооперативную и приоритетную многозадачность.

Создание задачи:
```
xTaskCreate(task_function, "Task Name", stack_size, parameters, priority, &task_handle);
```

ESP32 имеет два ядра (PRO_CPU (0) и APP_CPU (1)).
xTaskCreatePinnedToCore() - позволяет закрепить задачу за конкретным ядром. Если ядро не указано, задача может выполняться на любом ядре.